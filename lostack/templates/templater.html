{% extends "core.html" %}

{% block title %}YAML Template Generator{% endblock %}
{% block page_title %}YAML Template Generator{% endblock %}

{% block head %}
<!-- js-yaml (used by our yaml linting) -->
<script src="https://cdn.jsdelivr.net/npm/js-yaml@4.1.0/dist/js-yaml.min.js"></script>

<!-- CodeMirror 5 (core) + YAML mode + lint addons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/lint.min.css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/codemirror.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/mode/yaml/yaml.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/lint.min.js"></script>
<!-- yaml-lint integrates js-yaml with CodeMirror lint -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/codemirror/5.65.13/addon/lint/yaml-lint.min.js"></script>

<style>
  .yaml-block {
    flex: 1;
    display: flex;
    flex-direction: column;
    min-height: 0;
  }
  /* ensure CodeMirror fills available space */
  .cm-editor-wrap {
    height: 100%;
    display: flex;
    flex-direction: column;
  }
  .cm-editor-wrap .CodeMirror {
    flex: 1 1 auto;
    height: auto; /* let flex control height */
    min-height: 120px;
  }

  /* container sizing */
  .content-container {
    height: calc(100vh - 200px);
  }

  .form-row-horizontal {
    display: flex;
    gap: 1rem;
    flex-wrap: wrap;
  }
  .form-row-horizontal .form-group {
    flex: 1;
    min-width: 200px;
  }

  /* keep gutters comfortable on large split */
  .left-pane {
    padding-right: 1rem;
  }
  .right-pane {
    padding-left: 1rem;
  }
</style>
{% endblock %}

{% block content %}
<div class="content-container p-0">
  <div class="row h-100">
    <!-- Inputs (left on lg+) -->
    <div class="col-12 col-lg-6 d-flex flex-column left-pane">
      <h4 class="mb-3">Inputs</h4>
      <form id="yamlForm" class="needs-validation d-flex flex-column flex-grow-1">
        <div class="form-row-horizontal">
          <div class="form-group">
            <label for="image" class="form-label">Image</label>
            <input type="text" class="form-control" id="image" name="image" placeholder="nginx:latest">
          </div>

          <div class="form-group">
            <label for="port" class="form-label">Port</label>
            <input type="text" class="form-control" id="port" name="port" placeholder="8080">
          </div>

          <div class="form-group">
            <label for="serviceGroup" class="form-label">Homepage Group</label>
            <input type="text" class="form-control" id="serviceGroup" name="serviceGroup" placeholder="Apps">
          </div>

          <div class="form-group">
            <label for="serviceDescription" class="form-label">Homepage Description</label>
            <input type="text" class="form-control" id="serviceDescription" name="serviceDescription" placeholder="A short description">
          </div>

          <div class="form-group d-flex align-items-center">
            <div class="form-check form-switch me-2">
              <input type="checkbox" class="form-check-input" id="enableDuration" checked>
              <label class="form-check-label" for="enableDuration">Enable Duration</label>
            </div>
            <input type="text" class="form-control ms-2" id="duration" placeholder="30s" style="max-width:120px;" value="15m">
          </div>
        </div>

        <!-- YAML inputs side-by-side at md and up -->
        <div class="row mt-3 g-3 flex-grow-1">
          <div class="col-12 col-md-6 d-flex flex-column">
            <label for="dockerServiceYaml" class="form-label">Primary Service</label>
            <!-- original textarea preserved as CodeMirror target -->
            <div class="cm-editor-wrap">
              <textarea id="dockerServiceYaml" placeholder="Paste primary docker service YAML here" style="display:none;"></textarea>
            </div>
          </div>

          <div class="col-12 col-md-6 d-flex flex-column">
            <label for="additionalServicesYaml" class="form-label">Additional Services</label>
            <div class="cm-editor-wrap">
              <textarea id="additionalServicesYaml" placeholder="Paste additional docker services YAML here" style="display:none;"></textarea>
            </div>
          </div>
        </div>
      </form>
    </div>

    <!-- Output (right on lg+) -->
    <div class="col-12 col-lg-6 d-flex flex-column right-pane mt-4 mt-lg-0">
      <div class="yaml-block flex-grow-1">
        <div class="d-flex justify-content-between align-items-center mb-2">
          <h4>Depot Compose</h4>
          <button class="btn btn-sm btn-outline-primary" id="copyBtn">Copy</button>
        </div>

        <div class="cm-editor-wrap">
          <!-- readonly output target -->
          <textarea id="yaml1" readonly style="display:none;"></textarea>
        </div>
      </div>
    </div>
  </div>
</div>

<div class="toast-container position-fixed bottom-0 end-0 p-3">
  <div id="copyToast" class="toast align-items-center text-bg-success border-0" role="alert">
    <div class="d-flex">
      <div class="toast-body">
        âœ… Copied to clipboard!
      </div>
      <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast"></button>
    </div>
  </div>
</div>
{% endblock %}

{% block scripts %}
<script>
  // --- initialize CodeMirror editors with YAML mode + linting ---
  // options common to input editors
  const cmInputOptions = {
    mode: 'yaml',
    lineNumbers: true,
    gutters: ["CodeMirror-lint-markers"],
    lint: true,
    tabSize: 2,
    indentUnit: 2,
    autofocus: false,
    extraKeys: {"Tab": (cm) => cm.replaceSelection("  ")}
  };

  // create editors from the hidden textareas
  const dockerEditor = CodeMirror.fromTextArea(document.getElementById('dockerServiceYaml'), cmInputOptions);
  const additionalEditor = CodeMirror.fromTextArea(document.getElementById('additionalServicesYaml'), cmInputOptions);

  // output editor: YAML mode + linting, but readonly
  const outputEditor = CodeMirror.fromTextArea(document.getElementById('yaml1'), {
    mode: 'yaml',
    lineNumbers: true,
    gutters: ["CodeMirror-lint-markers"],
    lint: true,
    readOnly: 'nocursor',
    tabSize: 2,
    indentUnit: 2,
    viewportMargin: Infinity
  });

  // make the editors fill their parent via CSS.height adjustments: set the editor to use the wrapper height
  function setEditorHeights() {
    // compute available space inside each cm-editor-wrap and tell CodeMirror to refresh
    document.querySelectorAll('.cm-editor-wrap').forEach(wrap => {
      const cm = wrap.querySelector('.CodeMirror');
      if (!cm) return;
      // set CodeMirror's root to fill the wrapper
      wrap.style.minHeight = '120px';
      // force refresh so CM recalculates layout
    });
    dockerEditor.refresh();
    additionalEditor.refresh();
    outputEditor.refresh();
  }

  // initial refresh on load and on resize
  window.addEventListener('load', setEditorHeights);
  window.addEventListener('resize', () => {
    setEditorHeights();
  });

  // --- existing YAML generator logic updated to use editors ---
  const form = document.getElementById('yamlForm');
  const copyToastEl = document.getElementById('copyToast');
  const copyToast = new bootstrap.Toast(copyToastEl, { delay: 2000 });
  const enableDuration = document.getElementById('enableDuration');
  const duration = document.getElementById('duration');
  const copyBtn = document.getElementById('copyBtn');

  enableDuration.addEventListener('change', () => {
    duration.disabled = !enableDuration.checked;
    generateYAML();
  });

  function toYaml(obj, indent = 4) {
    const spaces = ' '.repeat(indent);
    if (typeof obj !== 'object' || obj === null) return String(obj);
    if (Array.isArray(obj)) {
      return obj.map(i => `${spaces}- ${toYaml(i, indent + 2).trim()}`).join('\n');
    }
    return Object.entries(obj).map(([k, v]) => {
      if (typeof v === 'object' && v !== null) {
        return `${spaces}${k}:\n${toYaml(v, indent + 2)}`;
      }
      return `${spaces}${k}: ${v}`;
    }).join('\n');
  }

  function getInternalPort(portMapping) {
    if (typeof portMapping !== "string") return portMapping;
    const parts = portMapping.split(":");
    return parts.length > 1 ? parts[1] : parts[0];
  }

  function processEnvironmentVariables(environment) {
    if (!environment) {
      return ['TZ=${TZ}'];
    }
    if (Array.isArray(environment)) {
      const filtered = environment.filter(env => !env.startsWith('TZ='));
      return ['TZ=${TZ}', ...filtered];
    }
    if (typeof environment === 'object') {
      const processed = { ...environment };
      processed.TZ = '${TZ}';
      return processed;
    }
    return environment;
  }

  function processDependsOn(dependsOn, primaryServiceName, isMainService) {
    if (!dependsOn) return null;
    if (!Array.isArray(dependsOn)) return dependsOn;

    if (isMainService) {
      return dependsOn.map(dep => `${primaryServiceName}-${dep}`);
    }

    return dependsOn.map(dep => {
      if (dep === primaryServiceName) return dep;
      return `${primaryServiceName}-${dep}`;
    });
  }

  function processService(serviceKey, serviceConfig, isMainService = false, primaryServiceName = '') {
    let composeObj = { ...serviceConfig };

    const image = document.getElementById('image').value || "IMAGE";
    const portInput = document.getElementById('port').value || "PORT";
    const serviceGroupInput = document.getElementById('serviceGroup').value;
    const serviceDescription = document.getElementById('serviceDescription').value || "";
    const durationValue = duration.value || "DURATION";

    composeObj.environment = processEnvironmentVariables(composeObj.environment);

    const serviceGroup = isMainService ? (serviceGroupInput || serviceKey) : "Databases";
    const description = isMainService ? serviceDescription : `${serviceKey} service`;
    const capitalizedServiceName = serviceKey.charAt(0).toUpperCase() + serviceKey.slice(1);
    const actualServiceKey = isMainService ? serviceKey : `${primaryServiceName}-${serviceKey}`;
    const displayName = isMainService ? capitalizedServiceName : `${primaryServiceName.charAt(0).toUpperCase() + primaryServiceName.slice(1)} ${capitalizedServiceName}`;

    delete composeObj.networks;
    delete composeObj.labels;

    composeObj.container_name = actualServiceKey;
    composeObj.hostname = actualServiceKey;
    composeObj.networks = ['traefik_network'];

    if (composeObj.depends_on) {
      const processedDependsOn = processDependsOn(composeObj.depends_on, primaryServiceName, isMainService);
      if (processedDependsOn) {
        composeObj.depends_on = processedDependsOn;
      } else {
        delete composeObj.depends_on;
      }
    }

    let labelsArray = [
      `homepage.description=${description}`,
      `homepage.group=${serviceGroup}`,
      `homepage.icon=${serviceKey}`,
      `homepage.name=${displayName}`,
      'sablier.enable=true',
      `sablier.group=${primaryServiceName}`
    ];

    if (isMainService) {
      labelsArray.push(
        `homepage.href=https://${actualServiceKey}.\${DOMAINNAME}/`,
        'traefik.enable=true',
        `traefik.http.routers.${actualServiceKey}.rule=Host(\`${actualServiceKey}.\${DOMAINNAME}\`)`,
        'lostack.primary=true'
      );

      const portsArr = serviceConfig.ports || [];
      if (portsArr.length === 1) {
        const internalPort = getInternalPort(portsArr[0]);
        labelsArray.push(`traefik.http.services.${actualServiceKey}.loadbalancer.server.port=${internalPort}`);
        delete composeObj.ports;
      } else if (portsArr.length > 1) {
        composeObj.ports = portsArr;
      } else {
        labelsArray.push(`traefik.http.services.${actualServiceKey}.loadbalancer.server.port=${portInput}`);
      }

      if (enableDuration.checked) {
        labelsArray.push(`lostack.duration=${durationValue}`);
      }
    }

    if (serviceConfig.labels) {
      Object.entries(serviceConfig.labels).forEach(([k, v]) => {
        if (!labelsArray.some(label => label.startsWith(k + '='))) {
          labelsArray.push(`${k}=${v}`);
        }
      });
    }

    labelsArray.sort((a, b) => a.localeCompare(b));
    composeObj.labels = labelsArray;

    return composeObj;
  }

  function generateYAML() {
    // read from CodeMirror editors
    const dockerServiceYaml = dockerEditor.getValue();
    const additionalServicesYaml = additionalEditor.getValue();

    let allServices = {};
    let mainServiceKey = "SERVICE";

    if (dockerServiceYaml.trim()) {
      try {
        const obj = jsyaml.load(dockerServiceYaml);
        if (obj && obj.services) {
          mainServiceKey = Object.keys(obj.services)[0];
          const serviceConfig = obj.services[mainServiceKey];
          allServices[mainServiceKey] = processService(mainServiceKey, serviceConfig, true, mainServiceKey);
        }
      } catch (err) {
        // parsing error - let lint show it; but still fallback to default service
        console.error("Invalid primary YAML:", err);
      }
    } else {
      const image = document.getElementById('image').value || "IMAGE";
      const defaultConfig = {
        image: image,
        restart: 'unless-stopped'
      };
      allServices[mainServiceKey] = processService(mainServiceKey, defaultConfig, true, mainServiceKey);
    }

    if (additionalServicesYaml.trim()) {
      try {
        const additionalObj = jsyaml.load(additionalServicesYaml);
        if (additionalObj && additionalObj.services) {
          Object.entries(additionalObj.services).forEach(([serviceKey, serviceConfig]) => {
            const prefixedServiceKey = `${mainServiceKey}-${serviceKey}`;
            allServices[prefixedServiceKey] = processService(serviceKey, serviceConfig, false, mainServiceKey);
          });
        }
      } catch (err) {
        console.error("Invalid additional services YAML:", err);
      }
    }

    let finalYaml = 'services:\n';
    Object.entries(allServices).forEach(([serviceKey, serviceConfig]) => {
      finalYaml += `  ${serviceKey}:\n${toYaml(serviceConfig, 4)}\n`;
    });

    // update the output editor
    outputEditor.setValue(finalYaml.trim());
    outputEditor.refresh(); // make sure lint runs
  }

  // copy button uses outputEditor content
  function copyToClipboardFromOutput() {
    const text = outputEditor.getValue();
    navigator.clipboard.writeText(text).then(() => {
      copyToast.show();
    });
  }

  // wire UI -> generate logic
  // update YAML when input editors change
  dockerEditor.on('change', generateYAML);
  additionalEditor.on('change', generateYAML);

  // also regenerate when form inputs change
  document.getElementById('image').addEventListener('input', generateYAML);
  document.getElementById('port').addEventListener('input', generateYAML);
  document.getElementById('serviceGroup').addEventListener('input', generateYAML);
  document.getElementById('serviceDescription').addEventListener('input', generateYAML);
  duration.addEventListener('input', generateYAML);

  // copy button
  copyBtn.addEventListener('click', copyToClipboardFromOutput);

  // initial population
  generateYAML();
  // ensure editors size correct after initial content
  setTimeout(() => {
    dockerEditor.refresh();
    additionalEditor.refresh();
    outputEditor.refresh();
  }, 100);
</script>
{% endblock %}
